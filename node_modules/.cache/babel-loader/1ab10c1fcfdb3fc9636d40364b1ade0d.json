{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (target) {\n  target.prototype.bindRemovalTracker = function () {\n    var _this = this;\n\n    var MutationObserver = getMutationObserverClass();\n    if (MutationObserver == null) return;\n    var observer = new MutationObserver(function (mutations) {\n      for (var m1 = 0; m1 < mutations.length; m1++) {\n        var mutation = mutations[m1];\n\n        for (var m2 = 0; m2 < mutation.removedNodes.length; m2++) {\n          var element = mutation.removedNodes[m2];\n\n          if (element === _this.state.currentTarget) {\n            _this.hideTooltip();\n\n            return;\n          }\n        }\n      }\n    });\n    observer.observe(window.document, {\n      childList: true,\n      subtree: true\n    });\n    this.removalTracker = observer;\n  };\n\n  target.prototype.unbindRemovalTracker = function () {\n    if (this.removalTracker) {\n      this.removalTracker.disconnect();\n      this.removalTracker = null;\n    }\n  };\n};\n/**\n * Tracking target removing from DOM.\n * It's necessary to hide tooltip when it's target disappears.\n * Otherwise, the tooltip would be shown forever until another target\n * is triggered.\n *\n * If MutationObserver is not available, this feature just doesn't work.\n */\n// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\n\n\nvar getMutationObserverClass = function getMutationObserverClass() {\n  return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n};","map":{"version":3,"sources":["D:/Coding/GitHub/zone/zone/node_modules/react-tooltip/dist/decorators/trackRemoval.js"],"names":["Object","defineProperty","exports","value","default","target","prototype","bindRemovalTracker","_this","MutationObserver","getMutationObserverClass","observer","mutations","m1","length","mutation","m2","removedNodes","element","state","currentTarget","hideTooltip","observe","window","document","childList","subtree","removalTracker","unbindRemovalTracker","disconnect","WebKitMutationObserver","MozMutationObserver"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIAD,OAAO,CAACE,OAAR,GAAkB,UAAUC,MAAV,EAAkB;AAClCA,EAAAA,MAAM,CAACC,SAAP,CAAiBC,kBAAjB,GAAsC,YAAY;AAChD,QAAIC,KAAK,GAAG,IAAZ;;AAEA,QAAIC,gBAAgB,GAAGC,wBAAwB,EAA/C;AACA,QAAID,gBAAgB,IAAI,IAAxB,EAA8B;AAE9B,QAAIE,QAAQ,GAAG,IAAIF,gBAAJ,CAAqB,UAAUG,SAAV,EAAqB;AACvD,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGD,SAAS,CAACE,MAAhC,EAAwCD,EAAE,EAA1C,EAA8C;AAC5C,YAAIE,QAAQ,GAAGH,SAAS,CAACC,EAAD,CAAxB;;AACA,aAAK,IAAIG,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGD,QAAQ,CAACE,YAAT,CAAsBH,MAA5C,EAAoDE,EAAE,EAAtD,EAA0D;AACxD,cAAIE,OAAO,GAAGH,QAAQ,CAACE,YAAT,CAAsBD,EAAtB,CAAd;;AACA,cAAIE,OAAO,KAAKV,KAAK,CAACW,KAAN,CAAYC,aAA5B,EAA2C;AACzCZ,YAAAA,KAAK,CAACa,WAAN;;AACA;AACD;AACF;AACF;AACF,KAXc,CAAf;AAaAV,IAAAA,QAAQ,CAACW,OAAT,CAAiBC,MAAM,CAACC,QAAxB,EAAkC;AAAEC,MAAAA,SAAS,EAAE,IAAb;AAAmBC,MAAAA,OAAO,EAAE;AAA5B,KAAlC;AAEA,SAAKC,cAAL,GAAsBhB,QAAtB;AACD,GAtBD;;AAwBAN,EAAAA,MAAM,CAACC,SAAP,CAAiBsB,oBAAjB,GAAwC,YAAY;AAClD,QAAI,KAAKD,cAAT,EAAyB;AACvB,WAAKA,cAAL,CAAoBE,UAApB;AACA,WAAKF,cAAL,GAAsB,IAAtB;AACD;AACF,GALD;AAMD,CA/BD;AAiCA;;;;;;;;AASA;;;AACA,IAAIjB,wBAAwB,GAAG,SAASA,wBAAT,GAAoC;AACjE,SAAOa,MAAM,CAACd,gBAAP,IAA2Bc,MAAM,CAACO,sBAAlC,IAA4DP,MAAM,CAACQ,mBAA1E;AACD,CAFD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (target) {\n  target.prototype.bindRemovalTracker = function () {\n    var _this = this;\n\n    var MutationObserver = getMutationObserverClass();\n    if (MutationObserver == null) return;\n\n    var observer = new MutationObserver(function (mutations) {\n      for (var m1 = 0; m1 < mutations.length; m1++) {\n        var mutation = mutations[m1];\n        for (var m2 = 0; m2 < mutation.removedNodes.length; m2++) {\n          var element = mutation.removedNodes[m2];\n          if (element === _this.state.currentTarget) {\n            _this.hideTooltip();\n            return;\n          }\n        }\n      }\n    });\n\n    observer.observe(window.document, { childList: true, subtree: true });\n\n    this.removalTracker = observer;\n  };\n\n  target.prototype.unbindRemovalTracker = function () {\n    if (this.removalTracker) {\n      this.removalTracker.disconnect();\n      this.removalTracker = null;\n    }\n  };\n};\n\n/**\n * Tracking target removing from DOM.\n * It's necessary to hide tooltip when it's target disappears.\n * Otherwise, the tooltip would be shown forever until another target\n * is triggered.\n *\n * If MutationObserver is not available, this feature just doesn't work.\n */\n\n// https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\nvar getMutationObserverClass = function getMutationObserverClass() {\n  return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n};"]},"metadata":{},"sourceType":"script"}